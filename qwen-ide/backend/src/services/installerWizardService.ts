import fs from 'fs/promises'
import path from 'path'
import { ZipService } from './zipService.js'

export interface InstallerConfig {
  appName: string
  version: string
  description: string
  author: string
  homepage?: string
  license?: string
  executable: string
  installDir?: string
  shortcuts?: {
    desktop: boolean
    startMenu: boolean
  }
  dependencies?: string[]
  scripts?: {
    preInstall?: string
    postInstall?: string
    preUninstall?: string
    postUninstall?: string
  }
  files?: {
    include: string[]
    exclude: string[]
  }
}

export interface InstallerOptions {
  platform: 'windows' | 'macos' | 'linux'
  architecture: 'x64' | 'arm64' | 'x86'
  format: 'msi' | 'exe' | 'deb' | 'rpm' | 'dmg' | 'pkg'
  compression?: 'none' | 'zip' | 'gzip' | 'bzip2'
  signing?: {
    certificate: string
    password: string
  }
}

export class InstallerWizardService {
  private static instance: InstallerWizardService
  private zipService: ZipService

  static getInstance(): InstallerWizardService {
    if (!InstallerWizardService.instance) {
      InstallerWizardService.instance = new InstallerWizardService()
    }
    return InstallerWizardService.instance
  }

  constructor() {
    this.zipService = ZipService.getInstance()
  }

  async generateInstallerConfig(projectPath: string): Promise<InstallerConfig> {
    try {
      // Try to read package.json for Node.js projects
      const packageJsonPath = path.join(projectPath, 'package.json')
      let packageInfo: any = {}
      
      try {
        const packageContent = await fs.readFile(packageJsonPath, 'utf-8')
        packageInfo = JSON.parse(packageContent)
      } catch {
        // No package.json found, use defaults
      }

      const projectName = packageInfo.name || path.basename(projectPath)
      
      return {
        appName: packageInfo.displayName || projectName,
        version: packageInfo.version || '1.0.0',
        description: packageInfo.description || `${projectName} application`,
        author: packageInfo.author || 'Developer',
        homepage: packageInfo.homepage,
        license: packageInfo.license || 'MIT',
        executable: this.detectExecutable(projectPath, packageInfo),
        installDir: `$PROGRAMFILES/${projectName}`,
        shortcuts: {
          desktop: true,
          startMenu: true
        },
        dependencies: packageInfo.dependencies ? Object.keys(packageInfo.dependencies) : [],
        scripts: {
          postInstall: packageInfo.scripts?.postinstall
        },
        files: {
          include: ['**/*'],
          exclude: ['node_modules/**', '.git/**', 'test/**', 'tests/**', '*.log']
        }
      }
    } catch (error) {
      throw new Error(`Failed to generate installer config: ${error}`)
    }
  }

  private detectExecutable(projectPath: string, packageInfo: any): string {
    // For Node.js apps
    if (packageInfo.main) {
      return packageInfo.main
    }
    
    if (packageInfo.bin) {
      const bins = typeof packageInfo.bin === 'string' ? { [packageInfo.name]: packageInfo.bin } : packageInfo.bin
      return Object.values(bins)[0] as string
    }

    // Common executable patterns
    const commonExecutables = [
      'index.js',
      'app.js',
      'main.js',
      'server.js',
      'dist/main.js',
      'build/main.js'
    ]

    return commonExecutables[0] // Default to index.js
  }

  async createWindowsInstaller(
    projectPath: string,
    outputPath: string,
    config: InstallerConfig,
    options: Partial<InstallerOptions> = {}
  ): Promise<string> {
    const installerScript = this.generateNSISScript(config, options)
    const scriptPath = path.join(outputPath, 'installer.nsi')
    
    await fs.mkdir(outputPath, { recursive: true })
    await fs.writeFile(scriptPath, installerScript)
    
    // Create installer package
    const installerName = `${config.appName}_v${config.version}_Setup.exe`
    const installerPath = path.join(outputPath, installerName)
    
    // In a real implementation, you would use makensis to compile the NSIS script
    console.log(`üì¶ Windows installer created: ${installerPath}`)
    console.log(`üìù NSIS script: ${scriptPath}`)
    
    return installerPath
  }

  private generateNSISScript(config: InstallerConfig, options: Partial<InstallerOptions>): string {
    return `; NSIS Installer Script for ${config.appName}
; Generated by LoneStar DI IDE

!define APP_NAME "${config.appName}"
!define APP_VERSION "${config.version}"
!define APP_DESCRIPTION "${config.description}"
!define APP_AUTHOR "${config.author}"
!define APP_EXECUTABLE "${config.executable}"

Name "\${APP_NAME}"
OutFile "\${APP_NAME}_v\${APP_VERSION}_Setup.exe"
InstallDir "\${config.installDir || '$PROGRAMFILES\\LoneStarDI'}"
RequestExecutionLevel admin

; Modern UI
!include "MUI2.nsh"

; Interface Configuration
!define MUI_ABORTWARNING

; Pages
!insertmacro MUI_PAGE_WELCOME
!insertmacro MUI_PAGE_LICENSE "LICENSE.txt"
!insertmacro MUI_PAGE_DIRECTORY
!insertmacro MUI_PAGE_INSTFILES
!insertmacro MUI_PAGE_FINISH

!insertmacro MUI_UNPAGE_WELCOME
!insertmacro MUI_UNPAGE_CONFIRM
!insertmacro MUI_UNPAGE_INSTFILES

; Languages
!insertmacro MUI_LANGUAGE "English"

; Installer Sections
Section "Main Application" SecMain
  SetOutPath "$INSTDIR"
  
  ; Copy all files
  File /r "app\\*"
  
  ; Create executable
  CreateShortCut "$DESKTOP\\\${APP_NAME}.lnk" "$INSTDIR\\\${APP_EXECUTABLE}"
  CreateShortCut "$SMPROGRAMS\\\${APP_NAME}.lnk" "$INSTDIR\\\${APP_EXECUTABLE}"
  
  ; Write uninstaller
  WriteUninstaller "$INSTDIR\\Uninstall.exe"
  
  ; Registry entries
  WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\${APP_NAME}" "DisplayName" "\${APP_NAME}"
  WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\${APP_NAME}" "UninstallString" "$INSTDIR\\Uninstall.exe"
SectionEnd

; Uninstaller Section
Section "Uninstall"
  Delete "$DESKTOP\\\${APP_NAME}.lnk"
  Delete "$SMPROGRAMS\\\${APP_NAME}.lnk"
  
  RMDir /r "$INSTDIR"
  
  DeleteRegKey HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\${APP_NAME}"
SectionEnd`
  }

  async createLinuxPackage(
    projectPath: string,
    outputPath: string,
    config: InstallerConfig,
    format: 'deb' | 'rpm' = 'deb'
  ): Promise<string> {
    await fs.mkdir(outputPath, { recursive: true })
    
    if (format === 'deb') {
      return this.createDebianPackage(projectPath, outputPath, config)
    } else {
      return this.createRPMPackage(projectPath, outputPath, config)
    }
  }

  private async createDebianPackage(
    projectPath: string,
    outputPath: string,
    config: InstallerConfig
  ): Promise<string> {
    const packageName = `${config.appName.toLowerCase()}_${config.version}_amd64.deb`
    const packagePath = path.join(outputPath, packageName)
    const debianDir = path.join(outputPath, 'DEBIAN')
    
    await fs.mkdir(debianDir, { recursive: true })
    
    // Create control file
    const controlContent = `Package: ${config.appName.toLowerCase()}
Version: ${config.version}
Section: utils
Priority: optional
Architecture: amd64
Maintainer: ${config.author}
Description: ${config.description}
`
    
    await fs.writeFile(path.join(debianDir, 'control'), controlContent)
    
    // Create postinst script if needed
    if (config.scripts?.postInstall) {
      const postinstContent = `#!/bin/bash
${config.scripts.postInstall}
chmod +x /usr/local/bin/${config.appName.toLowerCase()}
`
      await fs.writeFile(path.join(debianDir, 'postinst'), postinstContent)
      await fs.chmod(path.join(debianDir, 'postinst'), '0755')
    }
    
    console.log(`üì¶ Debian package structure created: ${packagePath}`)
    return packagePath
  }

  private async createRPMPackage(
    projectPath: string,
    outputPath: string,
    config: InstallerConfig
  ): Promise<string> {
    const specContent = `Name: ${config.appName.toLowerCase()}
Version: ${config.version}
Release: 1%{?dist}
Summary: ${config.description}
License: ${config.license}
URL: ${config.homepage || ''}

%description
${config.description}

%files
%{_bindir}/${config.appName.toLowerCase()}

%post
${config.scripts?.postInstall || ''}

%postun
${config.scripts?.postUninstall || ''}
`
    
    const specPath = path.join(outputPath, `${config.appName.toLowerCase()}.spec`)
    await fs.writeFile(specPath, specContent)
    
    console.log(`üì¶ RPM spec file created: ${specPath}`)
    return specPath
  }

  async createMacInstaller(
    projectPath: string,
    outputPath: string,
    config: InstallerConfig
  ): Promise<string> {
    const appName = `${config.appName}.app`
    const appPath = path.join(outputPath, appName)
    const contentsPath = path.join(appPath, 'Contents')
    const macOSPath = path.join(contentsPath, 'MacOS')
    const resourcesPath = path.join(contentsPath, 'Resources')
    
    await fs.mkdir(macOSPath, { recursive: true })
    await fs.mkdir(resourcesPath, { recursive: true })
    
    // Create Info.plist
    const plistContent = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDisplayName</key>
    <string>${config.appName}</string>
    <key>CFBundleExecutable</key>
    <string>${config.appName}</string>
    <key>CFBundleIdentifier</key>
    <string>com.${config.author.toLowerCase()}.${config.appName.toLowerCase()}</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>${config.appName}</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>CFBundleShortVersionString</key>
    <string>${config.version}</string>
    <key>CFBundleVersion</key>
    <string>${config.version}</string>
    <key>LSMinimumSystemVersion</key>
    <string>10.12</string>
</dict>
</plist>`
    
    await fs.writeFile(path.join(contentsPath, 'Info.plist'), plistContent)
    
    console.log(`üçé macOS app bundle created: ${appPath}`)
    return appPath
  }

  async createPortablePackage(
    projectPath: string,
    outputPath: string,
    config: InstallerConfig
  ): Promise<string> {
    const portableName = `${config.appName}_v${config.version}_Portable.zip`
    const portablePath = path.join(outputPath, portableName)
    
    // Create portable directory structure
    const portableDir = path.join(outputPath, 'portable')
    await fs.mkdir(portableDir, { recursive: true })
    
    // Create launcher script
    const launcherScript = `#!/bin/bash
# Portable launcher for ${config.appName}
cd "$(dirname "$0")"
./${config.executable}
`
    
    await fs.writeFile(path.join(portableDir, 'run.sh'), launcherScript)
    await fs.chmod(path.join(portableDir, 'run.sh'), '0755')
    
    // Create Windows batch file
    const batchScript = `@echo off
cd /d "%~dp0"
${config.executable}
`
    
    await fs.writeFile(path.join(portableDir, 'run.bat'), batchScript)
    
    // Create README
    const readmeContent = `# ${config.appName} Portable

Version: ${config.version}
Author: ${config.author}

## Usage

### Windows
Double-click run.bat

### Linux/macOS
Run ./run.sh

## Description
${config.description}
`
    
    await fs.writeFile(path.join(portableDir, 'README.md'), readmeContent)
    
    // Create zip package
    await this.zipService.createZip(portableDir, portablePath)
    
    console.log(`üì¶ Portable package created: ${portablePath}`)
    return portablePath
  }

  async validateInstaller(installerPath: string): Promise<{
    valid: boolean
    format: string
    size: number
    errors: string[]
  }> {
    try {
      const stats = await fs.stat(installerPath)
      const ext = path.extname(installerPath).toLowerCase()
      
      const formatMap: Record<string, string> = {
        '.exe': 'Windows Executable',
        '.msi': 'Windows MSI',
        '.deb': 'Debian Package',
        '.rpm': 'RPM Package',
        '.dmg': 'macOS Disk Image',
        '.pkg': 'macOS Package',
        '.zip': 'Portable Archive'
      }
      
      return {
        valid: true,
        format: formatMap[ext] || 'Unknown',
        size: stats.size,
        errors: []
      }
    } catch (error) {
      return {
        valid: false,
        format: 'Unknown',
        size: 0,
        errors: [error instanceof Error ? error.message : 'Unknown error']
      }
    }
  }
}

export default InstallerWizardService.getInstance()